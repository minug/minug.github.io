<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#33363b">
    <meta name="msapplication-TileColor" content="#33363b">
    
    
    
    
    <meta name="keywords" content="Life, ARIA, Hexo">
    
    
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    
    
    <link rel="icon" type="image/png" sizes="192x192" href="/favicons/android-chrome-192x192.png">
    
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
    
    
    <link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#33363b">
    
    
    <link rel="manifest" href="/favicons/site.webmanifest">
    
    
    <meta name="msapplication-config" content="/favicons/browserconfig.xml">
    
    
    <link rel="alternate" href="/atom.xml" title="Minug's Blog" type="application/atom+xml">
    
    
    <link rel="shortcut icon" type="image/x-icon" href="/favicons/favicon.ico">
    
    
    <link rel="stylesheet" type="text/css" href="/css/normalize.css">
    <link rel="stylesheet" type="text/css" href="/css/index.css">
    
    <link rel="stylesheet" type="text/css" href="/css/sidebar.css">
    
    
<link rel="stylesheet" type="text/css" href="/css/page.css">
<link rel="stylesheet" type="text/css" href="/css/post.css">

    <link rel="stylesheet" type="text/css" href="/css/custom.css">
    <link rel="stylesheet" type="text/css" href="/css/atom-one-dark.css">
    <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css">
    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script defer type="text/javascript" src="/js/util.js"></script>
    <script defer type="text/javascript" src="/js/scrollspy.js"></script>
    <script defer type="text/javascript" src="/js/fontawesome-all.min.js"></script>
    <script defer type="text/javascript" src="/js/lightgallery.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-fullscreen.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-hash.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-pager.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-thumbnail.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-zoom.min.js"></script>
    
    <script defer src="/js/busuanzi.pure.mini.js"></script>
    
    
    <script defer type="text/javascript" src="/js/search.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var searchPath = "search.xml";
      if (searchPath.length === 0) {
        searchPath = "search.xml";
      }
      var path = "/" + searchPath;
      searchFunc(path, "search-input", "search-result");
    });
    </script>
    
    
    <script defer type="text/javascript" src="/js/index.js"></script>
    
    <script defer type="text/javascript" src="/js/custom.js"></script>
    <title>Minug's Blog</title>
  </head>
  <body itemscope="" itemtype="http://schema.org/WebPage" lang="zh_CN" data-spy="scroll" data-target=".list-group">
    
<header id="header" class="header" style="background: #33363b;">
  <div class="container">
    <div class="header-container">
      <div class="header-title">
        <h1 class="title"><a href="/">Minug's Blog</a></h1>
        <h2 class="subtitle"></h2>
      </div>
      
      <div class="logo">
        <img src="/images/logo.png" alt="logo">
      </div>
      
    </div>
    <nav id="nav" class="nav">
      <a id="nav-toggle" class="nav-toggle" aria-hidden="true"><i class="fas fa-bars" aria-label="切换导航栏"></i></a>
      <ul id="menu" role="menubar" aria-hidden="false">
        
        <li role="menuitem"><a href="/" class="current">首页</a></li>
        
        <li role="menuitem"><a href="/tags/">标签</a></li>
        
        <li role="menuitem"><a href="/about/">关于</a></li>
        
      </ul>
    </nav>
  </div>
</header>


    <main id="main" class="main">
      <div class="container">
        <div class="main-container">
          <div class="content">
            

<div id="index" class="index page">
  
  <article class="article post card" itemscope="" itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="https://minug.github.io/2016/10/02/14753087875883/">
      <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
        <meta itemprop="name" content="XMinug">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.png">
      </span>
      <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="Minug's Blog">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2016/10/02/14753087875883/" itemprop="url">ios小技巧</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2016-10-02T00:00:00+08:00">2016-10-02 00:00</time></span>
        </span>
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="ios小技巧"><a href="#ios小技巧" class="headerlink" title="ios小技巧"></a>ios小技巧</h1><p><strong>1.</strong> 通过runtime的关联对象给对象额外增加实例。<br>关联对象,很聪明的做法就是使用_cmd指针作为key，不用再额外维护一个字符或其他对象。</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(self, _cmd, value, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line"></span><br><span class="line">objc_getAssociatedObject(self, _cmd)</span><br></pre></td></tr></table></figure>
<p><strong>2.</strong> JS中实现的消息转发</p>
<p><strong>3.</strong>关键字typeof()</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__weak typeof(self) weakSelf = self;</span><br></pre></td></tr></table></figure>
<p><strong>4.</strong>objectForKeyedSubscript:</p>
<p>实现了这个方法，就能以 a[key] 的形式来取值。</p>
<p><strong>5.</strong></p>
<pre><code>#if !__has_feature(objc_arc)
#error  does not support Objective-C Automatic Reference Counting (ARC)
#endif
</code></pre><p>通过这个宏来判断该文件是否支持ARC，如果不支持ARC，则报错。</p>

      
    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        <a class="post-tag button" href="/tags/iOS/" rel="tag"><i class="fas fa-tags"></i>iOS</a>
        
      </div>
      
    </footer>
  </article>
  
  <article class="article post card" itemscope="" itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="https://minug.github.io/2016/10/02/14753895285815/">
      <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
        <meta itemprop="name" content="XMinug">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.png">
      </span>
      <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="Minug's Blog">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2016/10/02/14753895285815/" itemprop="url">iOS开发相关内容</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2016-10-02T00:00:00+08:00">2016-10-02 00:00</time></span>
        </span>
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h2 id="iOS开发相关内容"><a href="#iOS开发相关内容" class="headerlink" title="iOS开发相关内容"></a>iOS开发相关内容</h2><h4 id="数据层"><a href="#数据层" class="headerlink" title="数据层"></a>数据层</h4><p>数据库持久化操作<br>fmdb,realm</p>
<h4 id="UI层"><a href="#UI层" class="headerlink" title="UI层"></a>UI层</h4><p>UITableview中自适应cell高度<a href="14753087034345.md">UITableview中cell自适应高度</a></p>
<p>轮播图实现,使用UICollectionView或者多个ImageView加上scrollView来展示。</p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>网络访问</p>
<h4 id="运营维护"><a href="#运营维护" class="headerlink" title="运营维护"></a>运营维护</h4><p>热更新<br>崩溃日志定位</p>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><p><a href="14754103000423.md">iOS常见内存泄露错误</a></p>
<h4 id="ios程序编译与逆向"><a href="#ios程序编译与逆向" class="headerlink" title="ios程序编译与逆向"></a>ios程序编译与逆向</h4><p>编译脚本</p>

      
    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        <a class="post-tag button" href="/tags/iOS/" rel="tag"><i class="fas fa-tags"></i>iOS</a>
        
      </div>
      
    </footer>
  </article>
  
  <article class="article post card" itemscope="" itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="https://minug.github.io/2016/10/02/14754103000423/">
      <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
        <meta itemprop="name" content="XMinug">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.png">
      </span>
      <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="Minug's Blog">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2016/10/02/14754103000423/" itemprop="url">iOS常见内存泄露错误</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2016-10-02T00:00:00+08:00">2016-10-02 00:00</time></span>
        </span>
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h4 id="iOS常见内存泄露错误"><a href="#iOS常见内存泄露错误" class="headerlink" title="iOS常见内存泄露错误"></a>iOS常见内存泄露错误</h4><p><strong>常见内存错误</strong><br><strong>1.</strong>memory leak</p>
<p>一般情况是，在某个方法的中通过new或者alloc，copy，create出一个新的对象之后，没有在该方法的最下方进行release操作。</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-(void)func&#123;</span><br><span class="line">    NSObject *obj = [[NSObject alloc] init];</span><br><span class="line">    [obj someMethod];</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.</strong>bad release</p>
<p>在某个方法的对不是通过new或者alloc，copy，create创建的新对象进行了一次release操作。</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-(void)func:(NSObject*)obj&#123;</span><br><span class="line">    [obj someMethod];</span><br><span class="line">    [obj release];</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.</strong>nil argument</p>
<p>对NSArray或者NSDictionary对象传入一个空指针。在代码中首先创建了一个某类型的空指针，然后在下面的switch或者ifelse中对指针赋值。然后将对象传入一个字典或者数组中。如果没有做default判断，然后将一个nil指针传入array中，造成crash</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-(void)func&#123;</span><br><span class="line">    NSString *s = nil;</span><br><span class="line">    switch Type&#123;</span><br><span class="line">        case 1:</span><br><span class="line">            s = @&quot;&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case 2:</span><br><span class="line">            s = @&quot;&quot;;</span><br><span class="line">            break;</span><br><span class="line">        case 3:</span><br><span class="line">            s = @&quot;&quot;;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    NSArray *a = @[s];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        <a class="post-tag button" href="/tags/iOS/" rel="tag"><i class="fas fa-tags"></i>iOS</a>
        
      </div>
      
    </footer>
  </article>
  
  <article class="article post card" itemscope="" itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="https://minug.github.io/2016/10/01/14753087034345/">
      <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
        <meta itemprop="name" content="XMinug">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.png">
      </span>
      <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="Minug's Blog">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2016/10/01/14753087034345/" itemprop="url">UITableview中cell自适应高度</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2016-10-01T00:00:00+08:00">2016-10-01 00:00</time></span>
        </span>
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h1 id="UITableview中cell自适应高度"><a href="#UITableview中cell自适应高度" class="headerlink" title="UITableview中cell自适应高度"></a>UITableview中cell自适应高度</h1><p>由于UITableview中cell展示时，会先调用其代理方法中的，<strong>- tableView:heightForRowAtIndexPath:</strong> 方法，来确定该cell的高度，然后再调用tableview的datasource方法，来创建展示该cell。对于一些类似聊天界面的tableview，我们不能返回一个固定的高度，需要先根据model里面的数据来计算这个cell的高度。</p>
<p><strong>第一种做法</strong>是根据data计算cell内视图的frame并手动布局界面。我一般的做法是在<strong>原来model的基础上再添加出一个frameModel层，</strong>作为隔离。因为model层只需要知道其本身内的数据，不需要具体了解具体展示其数据的cell的视图的布局规则。从另一个角度来说，同一个数据可能展示在不同的界面中，可能需要计算的frame也不同，所以不能把这个计算给写死在model层中。</p>
<p>这么做的优点是，<br><strong>1.</strong>计算量比autolayout要小。由于autolayout的计算是根据界面的布局，屏幕尺寸来进行实时的计算，并将重新排布视图。而我们手动的计算，我们可以添加一个缓存，来确保具体的布局计算只有一次。由于可以减少计算量，所以界面的流畅程度会比autolayout快一点。</p>
<p>但是缺点也是存在的，<br><strong>1.</strong>由于所有的计算需要我们手动来计算，代码的复杂度明显增加了。更加难维护了。因为需要另外抽出一个frameModel层，需要在这个对象里面手动添加计算的代码。如果需要自定义高度的cell很多的话，代码量上会增加很多。另外，<strong>这个frameModel需要知道cell中具体的视图布局规则，等于与cell直接耦合。如果以后需要修改cell的视图布局，则需要同时修改两处代码。</strong></p>
<p><strong>2.</strong>手动计算不能很好的支持横竖屏的切换。或者说，在写布局代码的时候，需要分别写入两套计算规则。而自动布局只需要根据界面的比例值来计算即可。</p>
<p><strong>第二种做法</strong>使用autolayout来自动布局。在ios8的时候，推出了<strong>self-sizing</strong>的概念，即对于例如UILabel，UIButton本身的高度可以根据里面的数据内容来撑开，即会有一个自身的高度存在。因此我们可以根据这个特性，利用autolayout来给cell设置约束，然后给cell传入数据后，让cell来自动布局，然后cell就会被”撑开”，我们就可以直接得到cell被撑开后的height，这个height我们需要在代理中返回的数据。<br>具体可以调用的就是</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (CGSize)systemLayoutSizeFittingSize:(CGSize)targetSize &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FDTemplateLayoutCell框架基于这个概念来实现ios开发中UITableView中cell高度计算。</p>
<p>简单调用的步骤即，</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line">    return [tableView fd_heightForCellWithIdentifier:@&quot;identifer&quot; cacheByIndexPath:indexPath configuration:^(id cell) &#123;</span><br><span class="line">        // 配置 cell 的数据源，和 &quot;cellForRow&quot; 干的事一致，比如：</span><br><span class="line">        cell.entity = self.feedEntities[indexPath.row];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单查看了一下框架中具体实现代码，<br>首先这是一个UITableview的分类，所以可以直接以tableview的形式来调用，而不用创建其他的对象。</p>
<p>首先根据cell的identifer和runtime来给tableview持有一个cell对象数组。这个cell对象不用于具体的展示，只是用来方便计算cellHeight。</p>
<p>每当具体调用到代理方法返回高度的时候，我们就可以传入一个identifer得到一个已regist过的cell，然后给cell来传入model数据。<strong>cell得到数据后，我们手动调用其自动布局的方法，得到通过autolayout计算得出的cellheight</strong>。</p>
<p>这么做的优点就是，在计算的时候不需要手动提前先计算cellHeight，也就不需要frameModel这个对象。代码更加简洁了。但是，每一次滑动tableview的时候，都会调用代理方法，我们需要重新计算一次cellHeight。<strong>而autolayout的计算量又远远大于手动计算</strong>，在流畅度上来说，体验远远差于手动计算。所以FDTemplateLayoutCell又提出了一个缓存的方法。可以根据indexPath或者key来实现数据的高度的缓存，如果第二次传入相同的key时，则直接返回缓存的数据，而不再重新计算。</p>
<p><strong>key的简单缓存做法即使用mutableDictionary来实现即可。</strong></p>
<p>讲一下使用indexpath来实现的缓存机制。<br>我们知道，在tableview中，刷新之后，可能原先indexpath对应的model即会出现新的变化，如果近简单的根据indexpath来进行数据缓存，则容易出现错位的情况。</p>
<p>主要的原理就是，通过分类覆写了UITableview的load方法，在load方法中，通过runtime将tableview的insert，reloadData等方法给hook成自己的方法。然后在替换的方法中手动管理indexpath变量。</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    // All methods that trigger height cache&apos;s invalidation</span><br><span class="line">    SEL selectors[] = &#123;</span><br><span class="line">        @selector(reloadData),</span><br><span class="line">        @selector(insertSections:withRowAnimation:),</span><br><span class="line">        @selector(deleteSections:withRowAnimation:),</span><br><span class="line">        @selector(reloadSections:withRowAnimation:),</span><br><span class="line">        @selector(moveSection:toSection:),</span><br><span class="line">        @selector(insertRowsAtIndexPaths:withRowAnimation:),</span><br><span class="line">        @selector(deleteRowsAtIndexPaths:withRowAnimation:),</span><br><span class="line">        @selector(reloadRowsAtIndexPaths:withRowAnimation:),</span><br><span class="line">        @selector(moveRowAtIndexPath:toIndexPath:)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    for (NSUInteger index = 0; index &lt; sizeof(selectors) / sizeof(SEL); ++index) &#123;</span><br><span class="line">        SEL originalSelector = selectors[index];</span><br><span class="line">        SEL swizzledSelector = NSSelectorFromString([@&quot;fd_&quot; stringByAppendingString:NSStringFromSelector(originalSelector)]);</span><br><span class="line">        Method originalMethod = class_getInstanceMethod(self, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(self, swizzledSelector);</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>个人意见，在使用FDTemplateLayoutCell的使用确实可以简化我们在不同高度的cell计算。同时，为了避免多次重复的计算，应该开启缓存机制。更好的是通过key来实现缓存。即可以根据model中的各个data生成一个哈希值作为key来缓存height，当data发生变化的时候，其哈希值也会变化，即可以促使tableview来重新计算数据。</p>

      
    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        <a class="post-tag button" href="/tags/iOS/" rel="tag"><i class="fas fa-tags"></i>iOS</a>
        
      </div>
      
    </footer>
  </article>
  
  <article class="article post card" itemscope="" itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="https://minug.github.io/2016/09/21/14743567013398/">
      <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
        <meta itemprop="name" content="XMinug">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.png">
      </span>
      <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="Minug's Blog">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2016/09/21/14743567013398/" itemprop="url">彩票业务学习与竞品分析</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2016-09-21T00:00:00+08:00">2016-09-21 00:00</time></span>
        </span>
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h4 id="彩票业务学习与竞品分析"><a href="#彩票业务学习与竞品分析" class="headerlink" title="彩票业务学习与竞品分析"></a>彩票业务学习与竞品分析</h4><p>因为刚开始涉及彩票应用，考虑到目前还没有专门使用过某一彩票应用来买彩票，就当做一个小白用户的初体验吧。<strong>下面所写都是胡说八道，看过即可。</strong></p>
<p>ps:话说现在购物类的应用图标都是红色。。淘宝，京东，当当，天猫的应用图标都是偏红色色系。。是因为红色能激发购买欲么。。</p>
<h4 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h4><p>作为彩票类的应用，提供的基础功能就是下单购买彩票。同时彩票又分为各种不同的彩种类型。在天天中彩票应用中，提供了双色球，大乐透，竞彩足球，竞彩篮球等可购买的彩票类型。</p>
<p>根据应用下方的tabbar，来简单的区分了下应用的提供的主要功能</p>
<p><img src="/media/14743567013398/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-09-21%20%E4%B8%8A%E5%8D%8810.39.46.png" alt=""></p>
<ol>
<li><p>首先是第一个购彩大厅，主要提供的就是购彩的功能，作为各个彩种的购买入口。给不同的彩种提供机选，自选功能，并直接下单购买。</p>
</li>
<li><p>其次是开奖公告，主要是用于显示各个彩种近期的中奖号码，简单来说就是一个公布栏的作用。</p>
</li>
<li><p>第三是比分直播，为关注足球与篮球的用户提供一个能够直接查看比分实况与赔率的入口。在竞彩足球的部分还提供了评论功能。虽然点了好多场的比赛，其下的点评里面消息数都是零，看见觉得好尴尬。</p>
</li>
<li><p>最后一个就是一个账户管理的部分，主要是关于账号，提现，订单查看的功能。</p>
</li>
<li>目前应用使用了腾讯的统一的帐号体系，即qq登录与微信登录。</li>
</ol>
<h4 id="竞品区别"><a href="#竞品区别" class="headerlink" title="竞品区别"></a>竞品区别</h4><p>选取了同样作为彩票应用的网易彩票与淘宝彩票作为竞品分析。<br><img src="/media/14743567013398/IMG_9312.png" width="70%"></p>
<p>承接上一个主题，直接从另外两个应用的tabbar分类来入手看看提供的功能有什么不同。</p>
<h4 id="网易彩票"><a href="#网易彩票" class="headerlink" title="网易彩票"></a>网易彩票</h4><p>网易彩票下方的tabbar有5个，<img src="/media/14743567013398/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-09-21%20%E4%B8%8A%E5%8D%8811.06.52.png" width="60%"></p>
<p>看的出来，网易彩票主打的方向是旗下的一元购商品。在一元购界面都是各种商品的介绍购买，手机，充值卡，等等不同种类的商品都参与了一元购的抽奖环节。</p>
<p>不过另一方面，网易彩票传统彩票状态都是暂停销售。所以整个应用提供的主要功能就是用于参与网易的一元购业务。不过感觉网易的一元购好像也有不少用户在参与使用。很多人也应该是被一元购来吸引使用网易彩票app。<br><img src="/media/14743567013398/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-09-21%20%E4%B8%8A%E5%8D%8811.11.23.png" width="40%"></p>
<p>另外，与天天中彩票应用不同的还有一点就是，网易彩票提供了一个”发现”模块。<br>仔细看了看，在发现模块下，各个不同的圈子中，参与人数与帖子数都不少。而天天中彩票应用的，能够进行消息交互的模块好像就是足球下面的点评，而且还基本没有数据。就是两方面对比，感觉网易彩票靠着圈子功能，即彩票社交类别吧，也是能够吸引不少用户，在圈子中各种交流自己的彩票心得或者用来炫耀。</p>
<p style="font-size:13px;">莫名想起了家门口的福利彩票小店，总是能见到一堆人聚扎在小店里面研究看看最近的彩票走势，聊聊最近的生活<br></p><br><img src="/media/14743567013398/IMG_9330.png" width="25%"><br><br>#### 淘宝彩票<br><br>而淘宝彩票，则是简单的4个tabbarItem，即为首页，娱乐场，开奖，以及我的界面。<br><br><img src="/media/14743567013398/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-09-21%20%E4%B8%8B%E5%8D%883.02.20.png"><br>简单来看，淘宝彩票也是提供了开奖信息与我的彩票界面。不过其主推的功能，与天天中彩票和淘宝彩票也不相同，是其娱乐场下的一些功能。看的出来，淘宝彩票主要提供的反而不是传统的彩票购买业务，而是基于其自己本身淘金币体系下推出的一系列新的玩法模式。反而更感觉像是一个自营的赌场模式。不过这应该也与政策有关系。<br><br><img src="/media/14743567013398/IMG_9332.png" width="50%"><img src="/media/14743567013398/IMG_9333.png" width="50%"><br><br>简单说一下自己的想法<br>天天中彩票是三个应用中唯一一个可以直接用来购买双色球，大乐透等普通传统彩票的应用。另外可以购买竞彩足球与竞彩篮球。简单猜测一下，应该是唯一一个拿到了彩票从业执照的应用。但是，有点类似一个单纯的彩票购买应用，与网易彩票和淘宝彩票相比，缺少了一点社交的元素。在网易彩票和淘宝彩票中，能够找到应用提供的一块讨论区，可以在里面简单的发送一些类似评论消息，给我的感觉有点更加具有生气。而天天中彩票中，虽然在竞彩足球下提供了一个点评的模块，不过在点进去看到寥寥无几的界面，感觉更是有点气氛尴尬。<br><br>另外网易彩票与淘宝彩票，都是提供了其自己的玩法，例如网易彩票的一元购，淘宝彩票的淘金币娱乐场。玩法比单独的彩票更加丰富一些，也可能更加吸引一下用户吧。<br><br>##### 界面区别<br><br><img src="/media/14743567013398/IMG_9314.png" width="30%"><img src="/media/14743567013398/IMG_9315.png" width="30%"><img src="/media/14743567013398/IMG_9317.png" width="30%"><img src="/media/14743567013398/IMG_9313.png" width="30%"><br>pps:吐槽一下刷新界面<br><p style="font-size:15px;">感觉网易彩票的刷新看起来更舒服一点</p>


      
    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        <a class="post-tag button" href="/tags/彩票业务/" rel="tag"><i class="fas fa-tags"></i>彩票业务</a>
        
      </div>
      
    </footer>
  </article>
  
  <article class="article post card" itemscope="" itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="https://minug.github.io/2016/09/12/14738707951975/">
      <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
        <meta itemprop="name" content="XMinug">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.png">
      </span>
      <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="Minug's Blog">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2016/09/12/14738707951975/" itemprop="url">2016暑期实习总结</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2016-09-12T00:00:00+08:00">2016-09-12 00:00</time></span>
        </span>
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h3 id="实习总结"><a href="#实习总结" class="headerlink" title="实习总结"></a>实习总结</h3><p>在来电中心度过了两个月的实习期。总结一下实习过程中的一些所感所受与技术上的内容提升。</p>
<h4 id="关于团队合作"><a href="#关于团队合作" class="headerlink" title="关于团队合作"></a>关于团队合作</h4><p>1，<strong>代码管理工具</strong>，团队主要使用的代码管理工具是SVN，加上分支开发的模式。</p>
<p>相比较之前使用的git，svn不是分布式的，所以没有本地仓库一说。等于说是大家所有提交的代码都保存在服务器上，需要查看提交记录的话，需要联网查看实时的全部记录，而不是类似git可以现在本地进行提交，然后再统一的push操作。</p>
<p>另外，对于一些需要忽略的文件，git是通过添加.gitignore文件来实现的，而svn，则是通过一些管理软件来实现的提交文件忽略，例如cornerstone就提供了这个功能。</p>
<p>svn上开出新的分支，则会将所有的文件拷贝出一份新文件，如果项目较大，并且有较多分支在存在的话，占用的硬盘空间是很可观的。例如tim的svn服务器上大概有5，6个分支和几个release的分支，每个工程大概占用里2G的空间。这些合起来，最后总共占用了接近20个G的空间。其中有相当一部分的文件都是完全一致的。</p>
<p>2，<strong>关于分支开发</strong>。大的需求开新分支操作，并且会保留一个开关。通过一个变量或者宏来控制新功能的开启与否。<br>或者如果考虑到一些临时性的功能开发，可以使用宏的形式，在后续需要删除的时候可以通过这些宏来快速定位代码位置。</p>
<p>3，新需求开发的主要流程，需求定制，宣讲，开发，产品体验，测试，合流。</p>
<p>4，<strong>关于一些开源库的使用</strong>。总的来说还是会在研究过源码的基础上，根据自己项目的一些业务需求进行一些个性化的定制，删除不必要的模块。</p>
<p>这个可能还是说需要仁者见仁智者见智了。</p>
<p>将开源库植入自己的应用中，主要原因就是因为需要使用到这个库所提供的功能。如果人手足够的话，抽空根据自己的项目进行一些个性化功能的订制优化，去除一些其他功能，对项目安装包或者性能都会有所帮助。可以直接下载源码后运行。</p>
<p>不过，如果没有时间进行一些源码级别的优化之类的话，可能使用cocoapods来管理第三方的库比较方便，因为开发者也会对自己的库进行一些优化。</p>
<p>5，<strong>内存泄露检测</strong>，动态与静态。</p>
<p>ios中的内存检测，主要还是简单分为了两类，</p>
<p>一个是动态内存检测，在应用运行过程中，根据控制器来检测。相对于Instruments，在debug环境下，如果产生内存泄露，可以直接弹框说明出现了内存泄露。主要检测原理是，判断依据是，认为当某个控制器被pop之后，其持有的变量与视图应该会被销毁。不过这样也会出现误报的情况。假设我们需要对某个控制器的视图进行缓存的话，就会出现误报的情况。</p>
<p>二是，通过静态代码扫描来检测。主要判断原理是mrc环境下的代码编写原则，在alloc或者new的下方，则同时应该配有一个release或者autorelease，在retain操作的下方也应该有一个release操作。</p>
<p>不过当我们编写程序的时候，没有根据这个原则来编写，则也会出现误报的情况。</p>
<p>扫描出来的问题主要有如下问题，</p>
<ol>
<li>bad release，即出现了二次释放，在该方法中的对一个不是通过new，copy，alloc出来的对象进行了release操作，则判断为bad release。</li>
<li>memory leak，通过alloc或者copy出来的对象在该方法的下方没有release操作。或者在方法中在if语句中提前return，而没有释放之前创建的对象。</li>
<li>nil parameter。创建了一个指针指向空对象，然后赋值。但是最后没有做边界判断，导致如果需要将这个指针的对象传入一个array或者dict中的话，就会出现传入一个空指针的情况。</li>
</ol>
<p>6，<strong>ipv6适配相关</strong>，会出现的问题与解决思路</p>
<p>7，<strong>安装包裁剪</strong>的主要思路。</p>
<ol>
<li>将工程中不需要的图片资源删除。</li>
<li>然后根据业务逻辑删除一些不再使用的功能。</li>
<li>重构重复的代码</li>
<li>将arc文件转换为mrc文件，可以稍微减少一点安装包的增量。</li>
<li>不要为了一点小功能就引入一个大的开源库。</li>
</ol>
<p>9，热修复注意事项。JS-Patch，通过加密算法来实现脚本传输过程中的安全事项。</p>

      
    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        <a class="post-tag button" href="/tags/实习总结/" rel="tag"><i class="fas fa-tags"></i>实习总结</a>
        
      </div>
      
    </footer>
  </article>
  
  <article class="article post card" itemscope="" itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="https://minug.github.io/2016/08/01/14817252088642/">
      <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
        <meta itemprop="name" content="XMinug">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.png">
      </span>
      <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="Minug's Blog">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2016/08/01/14817252088642/" itemprop="url">内存管理的两种实现</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2016-08-01T00:00:00+08:00">2016-08-01 00:00</time></span>
        </span>
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h4 id="内存管理的两种实现"><a href="#内存管理的两种实现" class="headerlink" title="内存管理的两种实现"></a>内存管理的两种实现</h4><h5 id="通过内存块头部管理引用计数"><a href="#通过内存块头部管理引用计数" class="headerlink" title="通过内存块头部管理引用计数"></a>通过内存块头部管理引用计数</h5><p>将引用计数保存在对象占用的块头部变量中。<br>即实现一个结构体</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct obj_layout &#123;</span><br><span class="line">char	padding[__BIGGEST_ALIGNMENT__ - ((UNP % __BIGGEST_ALIGNMENT__)</span><br><span class="line">  ? (UNP % __BIGGEST_ALIGNMENT__) : __BIGGEST_ALIGNMENT__)];</span><br><span class="line">NSUInteger	retained;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在结构体中保存当前这个变量的引用计数。</p>
<h5 id="通过计数引用表来实现计数管理"><a href="#通过计数引用表来实现计数管理" class="headerlink" title="通过计数引用表来实现计数管理"></a>通过计数引用表来实现计数管理</h5><p>而通过对Foundation框架的逆向，可以发现苹果的实现是通过计数表来保存每个实例变量的引用计数。</p>
<p>在计数表中，每个内存对象地址为键值，指向一个计数值。</p>
<h4 id="两种计数方式的对比："><a href="#两种计数方式的对比：" class="headerlink" title="两种计数方式的对比："></a>两种计数方式的对比：</h4><p>1，通过内存块头部管理引用计数，<br>代码简单，不用维护一个计数表。<br>可以统一管理引用技术的内存与对象的内存块。负责计数的内存块与对象本身的内存块是在一起的。</p>
<p>2，通过哈希表实现引用计数，<br>在创建分配内存块的时候不需要考虑内存块头部的分配<br>哈希表中有记录各个内存块的地址，可以通过这个追溯到各个具体的实例变量。</p>
<p>在实际调试的过程中，只要计数表没有被破坏，可以很方便的通过引用计数表来追踪各个对象的计数。<br>同时，统一管理计数的时候，不需要考虑由于单个内存块出现故障，导致该内存对象的计数值丢失的问题。</p>

      
    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        <a class="post-tag button" href="/tags/iOS/" rel="tag"><i class="fas fa-tags"></i>iOS</a>
        
      </div>
      
    </footer>
  </article>
  
  <article class="article post card" itemscope="" itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="https://minug.github.io/2016/08/01/14817266761435/">
      <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
        <meta itemprop="name" content="XMinug">
        <meta itemprop="description" content="">
        <meta itemprop="image" content="/images/avatar.png">
      </span>
      <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
        <meta itemprop="name" content="Minug's Blog">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">
        <a class="post-title-link post-title-link-external" href="/2016/08/01/14817266761435/" itemprop="url">autorelease 的实现</a>
      </h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2016-08-01T00:00:00+08:00">2016-08-01 00:00</time></span>
        </span>
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      
      <h3 id="autorelease-的实现"><a href="#autorelease-的实现" class="headerlink" title="autorelease 的实现"></a>autorelease 的实现</h3><p>调用autorelease 方法速度比较快的原因：<br>在 NSObject 的 initialize方法中，通过<br>static IMP autorelease_imp 来对 NSAutoreleasePool 的 @selector(addObject:) 方法进行了缓存，以后调用不需要通过查找，直接通过该方法指针进行调用即可。</p>
<p>实际调用结果等同于</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-( id )autorelease&#123;</span><br><span class="line">    [NSAutoreleasePool addObject:self];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 NSAutoreleasePool 内部，具体实现为</p>
<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+(id)addObject:(id)obj&#123;</span><br><span class="line">    pool = currentPool();</span><br><span class="line">    [pool addObject:obj];</span><br><span class="line">&#125;</span><br><span class="line">- (void) addObject: (id)anObj&#123;</span><br><span class="line">    [autorelease_array_lisy addObject:anobj];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即在pool内部会维护一个数组，每个被添加到pool内部的对象都会添加到数组中去。</p>
<p>当pool被调用到 drain方法时，会将pool内所管理的对象进行一个release操作，然后dealloc销毁自身。</p>
<p>我们可以通过@autoreleasepool{<br>//code<br>}<br>来自己创建并管理一个pool，也可以使用系统维护的autoreleasepool来实现内存的释放。</p>
<p>而由系统来维护的autoreasepool则会在runtim的运行过程中不断的创建与销毁，来实现内部变量的释放</p>
<p><a href="http://www.cocoachina.com/ios/20150610/12093.html" target="_blank" rel="noopener">http://www.cocoachina.com/ios/20150610/12093.html</a></p>

      
    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        <a class="post-tag button" href="/tags/iOS/" rel="tag"><i class="fas fa-tags"></i>iOS</a>
        
      </div>
      
    </footer>
  </article>
  
  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right" aria-label="下一页"></i></a>
  </nav>
  
  
</div>

          </div>
          
          
          
<aside class="sidebar" id="sidebar" style="background: url(/images/background.png);">
  
  <div class="search">
    <div class="form-group">
      <i class="fas fa-search"></i><input type="search" id="search-input" name="q" results="0" placeholder="搜索" class="form-control">
    </div>
  </div>
  <div class="search-result-box" id="search-result"></div>
  
  
<div class="info sidebar-item" id="info">
  
  <img class="author-avatar" src="/images/avatar.png" alt="XMinug">
  
  <h1 class="author-name">XMinug</h1>
  <h2 class="author-description"></h2>
  <div class="site-count">
    
    
    
    
    <div class="tags-count">
      <div class="site-count-title">标签</div>
      <div><a href="/tags/">5</a></div>
    </div>
    
  </div>
  
  <div class="rss">
    <a class="rss-link button sidebar-item" href="/atom.xml"><i class="fas fa-rss"></i>RSS</a>
  </div>
  
</div>


  <div class="sidebar-sticky">
    
    
    <hr>
    <div class="social-link sidebar-item">
      <div><i class="far fa-address-card"></i>社交链接<p></p></div>
      <ul>
        
        <li><i class="fas fa-envelope"></i><a href="" target="_blank">xminug#gmail.com</a></li>
        
        <li><i class="fab fa-github"></i><a href="https://github.com/minug" target="_blank">GitHub</a></li>
        
      </ul>
    </div>
    
    
    <hr>
    <div class="blogroll sidebar-item">
      <div><i class="fas fa-link"></i>友情链接</div>
      <ul>
        
        <li><i class="fas fa-link"></i><a href="https://minug.github.io/" target="_blank">GitHub</a></li>
        
      </ul>
    </div>
    
  </div>
</aside>


          
        </div>
      </div>
    </main>
    
<footer id="footer" class="footer" style="background: #33363b;">
  <div class="container">
    <div class="back-to-top">
      <button id="back-to-top"><i class="fas fa-angle-double-up" aria-label="回到顶部"></i></button>
    </div>
    <div class="footer-container">
      <div class="footer-left">
        <div class="copyright">
          <span class="author">XMinug</span><span class="year"><i class="far fa-copyright"></i>2018</span>
        </div>
        
        <div class="busuanzi">
          <span id="busuanzi_container_site_pv"><i class="fas fa-eye" aria-label="站点点击量" aria-hidden="false"></i><span id="busuanzi_value_site_pv"></span></span><span id="busuanzi_container_site_uv"><i class="fas fa-user" aria-label="站点用户数" aria-hidden="false"></i><span id="busuanzi_value_site_uv"></span></span><span id="busuanzi_container_page_pv"><i class="far fa-file-alt"></i><span id="busuanzi_value_page_pv" aria-label="页面点击量" aria-hidden="false"></span></span>
        </div>
        
      </div>
      <div class="footer-right">
        <div class="custom-info">
          
          托管于<i class="fab fa-github-alt"></i><a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
          
        </div>
        <div class="powered-by">
          由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动 | 主题 <a href="https://github.com/AlynxZhou/hexo-theme-aria/" target="_blank">ARIA</a>
        </div>
      </div>
    </div>
  </div>
</footer>


  </body>
</html>
